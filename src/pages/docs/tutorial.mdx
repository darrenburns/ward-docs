---
title: "Tutorial: Getting started"
path: "/guide/tutorial"
section: "user guide"
---
import Warning from "../../components/warning"
import TestOutputLine from "../../components/ward-test-output"

Ward is available on [PyPI](https://pypi.org/project/ward/), so it can be installed using `pip`.

```text
pip install ward
```

When you run `ward` with no arguments, it will recursively look for tests starting from your current directory.

Ward will look for tests in any Python file with a name that starts with `test_`.

We're going to write tests for a function called `contains`, shown below.

```python
def contains(list_of_items, target_item):
    for current_item in list_of_items:
        if current_item == target_item:
            return True
    return False
```

This function should return `True`, if the `target_item` is contained within `list_of_items`. Otherwise it should return `False`.

## Our first test

Tests in ward are just Python functions annotated with the `@test(description: str)` decorator.

Functions annotated with this decorator can be named `_`. We'll tell readers
 what the test does using a plain English description rather than the function name.

Our test is contained within a file called `test_contains.py`:

```python
from contains import contains
from ward import expect, test

@test("contains returns True when item is in list")
def _():
    list_of_items = list(range(10))
    result = contains(list_of_items, 5)
    expect(result).equals(True)
```

In this file, we've defined a single test function called `_`. It's been
annotated with `@test`, and has a helpful description. We don't have to read the code inside the test to understand its purpose.

The description can be queried when running a subset of 
tests. You may decide to use your own conventions inside the description
in order to make your tests highly queryable.

Now we can run `ward` in our terminal. Ward will find and run the test, and
confirm that the test pases with a message like the one below.

<TestOutputLine marker="PASS" lineNumber="4" moduleName="test_contains" description="contains returns True when item is in list" />

<br/>

## Extracting common setup code

Lets add another test.

```python
@test("contains returns False when item is not in list")
def _():
    list_of_items = list(range(100000))
    result = contains(list_of_items, -1)
    expect(result).equals(False)
```

This test begins by instantiating the same list of 10 integers as the first
test. This duplicated setup code can be extracted out into a *fixture* so that we
don't have to repeat ourselves at the start of every test.

The `@fixture` decorator lets us define a fixture, which is a unit of test setup code. It can optionally contain some additional code to clean up any resources
the it used (e.g. cleaning up a test database).

Lets define a fixture immediately above the tests we just wrote.

```python
from ward import fixture

@fixture
def list_of_items():
    return list(range(100000))
```

We can now rewrite our tests to make use of this fixture. Here's how we'd rewrite the second test.

```python
@test("contains returns False when item is not in list")
def _(l=list_of_items):
    result = contains(l, -1)
    expect(result).equals(False)
```

By binding the name of the fixture as a default argument to the test, Ward will
resolve it before the test runs, and inject it into the test. 

By default, a fixture is executed immediately before being injected into
a test. In the case of `list_of_items`, that could be problematic if lots of tests
depend on it. Do we really want to instantiate a list of 100000 integers before
each of those tests? Probably not.

### Fixture scope

To avoid this repeated expensive test setup, you can tell Ward what the *scope* of a fixture is. The scope of a fixture defines how long it should be cached for.

Ward supports 3 scopes: `test` (default), `module`, and `global`.

* A `test` scoped fixture will be executed at most once per test.
* A `module` scoped fixture will be executed at most once per module.
* A `global` scoped fixture will be executed at most once per invocation of `ward`.

We can safely say that we only need to generate our `list_of_items` once, and we can reuse its value in every test that depends on it. So lets give it a `global` scope:

```python
from ward import fixture, Scope

@fixture(scope=Scope.Global)  # or scope="global"
def list_of_items():
    return list(range(100000))
```

With this change, our fixture will now only be executed once, regardless of how
many tests depend on it. Careful management of fixture scope can drastically reduce the time and resources required to run a suite of tests.

As a general rule of thumb, if the value returned by a fixture is immutable, or we know that no test will mutate it, then we can make it `global`. 

<Warning>
**Warning**: You should *never* mutate a `global` or `module` scoped fixture. Doing so breaks
the isolated nature of tests, and introduces hidden dependencies between them. Ward will warn you if it detects a `global` or `module` scoped fixture has been mutated inside a test (coming in v1.0).
</Warning>